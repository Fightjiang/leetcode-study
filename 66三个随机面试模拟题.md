## 1.位1的个数
编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。

示例 1：
```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```
示例 2：
```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```
示例 3：
```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

提示：

* 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
* 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

##### 题感：虽然 uint32_t 不懂 ， 但是原理还是不变滴 。 

```C++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int ans = 0 ; 
        while(n) {
            ans += n & 1 ; 
            n >>= 1 ;
        }
        return ans  ; 
    }
};
```

## 2.旋转数组
给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1:
```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```
示例 2:
```
输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```
说明:

* 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
* 要求使用空间复杂度为 O(1) 的 原地 算法。

##### 题感：环形解法不错 ， 就是要理清思路 ， 使用反转更牛逼 ， 我也不懂原理 。

* 环形解法：
	```C++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k = k % nums.size() ; 
        int count = 0 ; 
        for(int start = 0 ;  count < nums.size() ; start++) {
            int current = start ; 
            int prev = nums[start] ; 
            do {
                int next = (current + k) % nums.size() ; 
                int tmp = nums[next] ; 
                nums[next] = prev ; 
                current = next ; 
                prev = tmp ; 
                count++ ; 
            }while(start != current) ; 
        }
    }
};
    ```
* 使用反转
	```C++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        reverse(nums.begin() , nums.end() ) ; 
        k = k % nums.size() ;
        reverse(nums.begin() , nums.begin() + k) ;
        reverse(nums.begin() + k , nums.end()) ; 
    }
};
    ```
    
## 3. 阶乘后的零
给定一个整数 n，返回 n! 结果尾数中零的数量。

示例 1:
```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```
示例 2:
```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
说明: 你算法的时间复杂度应为 O(log n) 。
```

##### 题感：可以分析出 ， 要的就是因子 5 的数量。
```C++
class Solution {
public:
    int trailingZeroes(int n) {
        int count_5 = 0 ;
        while(n) {
            count_5 += n/5 ; 
            n/=5 ;
        }
        return count_5 ;
    }
};
```