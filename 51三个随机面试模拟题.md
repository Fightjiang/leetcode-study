## 1.颠倒二进制位
颠倒给定的 32 位无符号整数的二进制位。

示例 1：
```
输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```
示例 2：
```
输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
      因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。
```

提示：

* 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
* 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。
 

进阶:
> 如果多次调用这个函数，你将如何优化你的算法？

##### 题感：巧妙的位运算，虽然我没看懂 uint32_t 的用法，本地的输出还和 leetcode 上不对，但是这题的精髓是位运算，掌握了就好哒 。 
```C++
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        int i=32;
        uint32_t res=0;
        while(i--)
        {
            res<<=1;//向左移一位
            res+=n&1;
         //   cout<<res<<" "<<n<<endl ; 
            n>>=1;//向右移一位
        }
        return res;
    }
};
```
## 2.旋转函数

给定一个长度为 n 的整数数组 A 。

假设 Bk 是数组 A 顺时针旋转 k 个位置后的数组，我们定义 A 的“旋转函数” F 为：

> F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]。

> 计算F(0), F(1), ..., F(n-1)中的最大值。

注意:
可以认为 n 的值小于 105。

示例:
```
A = [4, 3, 2, 6]

F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26

所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。
```
##### 题感：感觉就是规律题，但是找了半天木有找到，最后看的题解。
```C++
class Solution {
public:
    typedef vector<int>::size_type size_int ; 
    typedef long long ll ; 
    int maxRotateFunction(vector<int>& A) {
        ll sum = 0 , f0 = 0 , i = 0 ; 
        for(auto a : A){
            sum += a ;
            f0 =f0 + (i++) * a ;  
        }
        ll  max_value = f0 ; 
        size_int len = A.size() ; 
        for(size_int i = 1 ; i < len ; i++){
            ll tmp = f0 + sum - A[len - i] * len ;
            f0 = tmp ; 
            max_value = max(tmp , max_value) ;   
        }
        return max_value ; 
    }
};
```
## 3. 三数之和的多种可能
给定一个整数数组 A，以及一个整数 target 作为目标值，返回满足` i < j < k 且 A[i] + A[j] + A[k] == target `的元组` i, j, k `的数量。

由于结果会非常大，请返回 结果除以` 10^9 + 7 `的余数。

示例 1：
```
输入：A = [1,1,2,2,3,3,4,4,5,5], target = 8
输出：20
解释：
按值枚举（A[i]，A[j]，A[k]）：
(1, 2, 5) 出现 8 次；
(1, 3, 4) 出现 8 次；
(2, 2, 4) 出现 2 次；
(2, 3, 3) 出现 2 次。
```
示例 2：
```
输入：A = [1,1,2,2,2,2], target = 5
输出：12
解释：
A[i] = 1，A[j] = A[k] = 2 出现 12 次：
我们从 [1,1] 中选择一个 1，有 2 种情况，
从 [2,2,2,2] 中选出两个 2，有 6 种情况。
 ```

提示：

* 3 <= A.length <= 3000
* 0 <= A[i] <= 100
* 0 <= target <= 300

##### 题感：提交了很多次，最后写了个 set 排重的的过了，但是看了题解发现了精髓。
思路： 我们对于`a + b + c == target`主要存在这样的三种情况 ， 因为这是个组合的问题，然后枚举暴力就好了。

1. a == b == c
2. a == b != c
3. a < b and b < c 

```C++
class Solution {
public:
    typedef vector<int>::size_type size_int ; 
    typedef long long ll; 
    int mod = 1000000007 ;  

    int threeSumMulti(vector<int>& A, int target) {
        unordered_map<int,ll> p ;
        vector<int> AA ; 
        for(auto a : A){
            if(p[a] == 0){
                AA.push_back(a) ; 
            }
            p[a]++ ; 
        }

        size_int len = AA.size() ; 
        set<int> quchong ; 
        ll sum = 0 ; 
        for(size_int i = 0 ; i < len ; i++){
            ll a = AA[i] ; 
            for(size_int j = 0 ; j < len ; j++){
                int b = AA[j] ; 
                int c = target - a - b ; 
                if(a == b && b == c &&  p[a] >= 3 ) {
                    sum = (sum + (((p[a]*(p[a]-1))*(p[a]-2))/6))%mod ; 
                }else if(a == b && b != c){
                    sum = (sum + ((((p[a]*(p[a]-1)) % mod )/2)*p[c])%mod)%mod ; 
                }else if( c > b && b > a ){
                    sum = (sum + (((p[a]*p[b])%mod)*p[c])%mod)%mod ; 
                }
            }
        }
        return sum ; 
    }
};
```