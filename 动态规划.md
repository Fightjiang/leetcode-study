<!-- GFM-TOC -->
* [斐波那契数列](#斐波那契数列)
    * [1. 爬楼梯](#1-爬楼梯)
    * [2. 强盗抢劫](#2-强盗抢劫)
    * [3. 强盗在环形街区抢劫](#3-强盗在环形街区抢劫)
    * [4. 信件错排](#4-信件错排)
    * [5. 母牛生产](#5-母牛生产)
* [矩阵路径](#矩阵路径)
    * [1. 矩阵的最小路径和](#1-矩阵的最小路径和)
    * [2. 矩阵的总路径数](#2-矩阵的总路径数)
* [数组区间](#数组区间)
    * [1. 数组区间和](#1-数组区间和)
    * [2. 数组中等差递增子区间的个数](#2-数组中等差递增子区间的个数)
* [分割整数](#分割整数)
    * [1. 分割整数的最大乘积](#1-分割整数的最大乘积)
    * [2. 按平方数来分割整数](#2-按平方数来分割整数)
    * [3. 分割整数构成字母字符串](#3-分割整数构成字母字符串)
* [最长递增子序列](#最长递增子序列)
    * [1. 最长递增子序列](#1-最长递增子序列)
    * [2. 一组整数对能够构成的最长链](#2-一组整数对能够构成的最长链)
    * [3. 最长摆动子序列](#3-最长摆动子序列)
* [最长公共子序列](#最长公共子序列)
    * [1. 最长公共子序列](#1-最长公共子序列)
* [0-1 背包](#0-1-背包)
    * [1. 划分数组为和相等的两部分](#1-划分数组为和相等的两部分)
    * [2. 改变一组数的正负号使得它们的和为一给定数](#2-改变一组数的正负号使得它们的和为一给定数)
    * [3. 01 字符构成最多的字符串](#3-01-字符构成最多的字符串)
    * [4. 找零钱的最少硬币数](#4-找零钱的最少硬币数)
    * [5. 找零钱的硬币数组合](#5-找零钱的硬币数组合)
    * [6. 字符串按单词列表分割](#6-字符串按单词列表分割)
    * [7. 组合总和](#7-组合总和)
* [股票交易](#股票交易)
    * [1. 需要冷却期的股票交易](#1-需要冷却期的股票交易)
    * [2. 需要交易费用的股票交易](#2-需要交易费用的股票交易)
    * [3. 只能进行两次的股票交易](#3-只能进行两次的股票交易)
    * [4. 只能进行 k 次的股票交易](#4-只能进行-k-次的股票交易)
* [字符串编辑](#字符串编辑)
    * [1. 删除两个字符串的字符使它们相等](#1-删除两个字符串的字符使它们相等)
    * [2. 编辑距离](#2-编辑距离)
    * [3. 复制粘贴字符](#3-复制粘贴字符)
<!-- GFM-TOC -->




递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。

# 斐波那契数列

## 1. 爬楼梯

70\. Climbing Stairs (Easy)

[Leetcode](https://leetcode.com/problems/climbing-stairs/description/) / [力扣](https://leetcode-cn.com/problems/climbing-stairs/description/)

题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。

定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。

第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。

<!--<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=dp[i-1]+dp[i-2]" class="mathjax-pic"/></div> <br>-->

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14fe1e71-8518-458f-a220-116003061a83.png" width="200px"> </div><br>

考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。

```C++
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 2) {
            return n;
        }
        int pre2 = 1, pre1 = 2;
        for (int i = 2; i < n; i++) {
            int cur = pre1 + pre2;
            pre2 = pre1;
            pre1 = cur;
        }
        return pre1;
    }
};
```

## 2. 强盗抢劫

198\. House Robber (Easy)

[Leetcode](https://leetcode.com/problems/house-robber/description/) / [力扣](https://leetcode-cn.com/problems/house-robber/description/)

题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。

定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。

由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以

<!--<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=max(dp[i-2]+nums[i],dp[i-1])" class="mathjax-pic"/></div> <br>-->

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2de794ca-aa7b-48f3-a556-a0e2708cb976.jpg" width="350px"> </div><br>

```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        // f(x) = max(f(x - 2) + num , f(x-1)) ;
        int prenum = 0, curnum = 0 , Maxnum = 0;
        for(int num : nums){
            Maxnum = max(prenum + num , curnum) ;
            prenum = curnum ;  
            curnum = Maxnum ;
        }
        return Maxnum ;
    }
};
```

## 3. 强盗在环形街区抢劫

213\. House Robber II (Medium)

[Leetcode](https://leetcode.com/problems/house-robber-ii/description/) / [力扣](https://leetcode-cn.com/problems/house-robber-ii/description/)


```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        // 1 2 3 4 5
        if(nums.size() == 1) {
            return nums[0] ; 
        }
        return max(judge(nums , 0 , nums.size() - 1) , judge(nums , 1 , nums.size())) ;
    }

    int judge(vector<int> &nums , int l , int r) {
        int prenum = 0 , curnum = 0 , Maxnum = 0 ; 
        for(int i = l ; i < r ; ++i) {
            Maxnum = max(nums[i] + prenum , curnum) ; 
            prenum = curnum ; 
            curnum = Maxnum ;
        }
        return Maxnum ; 
    }
};
```

## 4. 信件错排

题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量（所有信封都没有装各自的信）。

定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：

- i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)\*dp[i-2] 种错误装信方式。
- i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)\*dp[i-1] 种错误装信方式。

综上所述，错误装信数量方式数量为：

<!--<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=(i-1)*dp[i-2]+(i-1)*dp[i-1]" class="mathjax-pic"/></div> <br>-->

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/da1f96b9-fd4d-44ca-8925-fb14c5733388.png" width="350px"> </div><br>

## 5. 母牛生产

[程序员代码面试指南-P181](#)

题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。

第 i 年成熟的牛的数量为：

<!--<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=dp[i-1]+dp[i-3]" class="mathjax-pic"/></div> <br>-->

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/879814ee-48b5-4bcb-86f5-dcc400cb81ad.png" width="250px"> </div><br>
